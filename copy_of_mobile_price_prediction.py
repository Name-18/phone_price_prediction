# -*- coding: utf-8 -*-
"""Copy of mobile_price_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JCKcMoFeCUZsN7v21UjUMOmyWH6NrTye
"""

import pandas as pd
import numpy as np

df=pd.read_csv('mobiles1.csv')
df.head()

# @title Distribution of Ratings

import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
plt.hist(df['rating'], bins=10, edgecolor='black')
plt.title('Distribution of Ratings')
plt.xlabel('Rating')
_ = plt.ylabel('Frequency')

# @title price vs rating

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='price', y='rating', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title price

from matplotlib import pyplot as plt
df['price'].plot(kind='hist', bins=20, title='price')
plt.gca().spines[['top', 'right',]].set_visible(False)

df['reviews']=df['reviews'].str.replace("Reviews","")

df['battery_num'] = df['battery'].str.extract('(\d+)')
df['battery_num'] = pd.to_numeric(df['battery_num'], errors='coerce').fillna(0).astype(int)

df=df.drop(['battery'],axis=1)

df.head()

data1=df.copy()

data1[['RAM', 'ROM', 'Expandable_Memory']] = data1['memory'].str.extract(
    r'(\d+\s*GB\s*RAM)\s*\|\s*(\d+\s*GB\s*ROM)(?:\s*\|\s*Expandable\s*Upto\s*(\d+\s*GB))?'
)

data1.head()

data1['RAM'] = data1['RAM'].str.replace('GB', '', regex=True)
data1['ROM'] = data1['ROM'].str.replace('GB', '', regex=True)
data1['Expandable_Memory'] = data1['Expandable_Memory'].str.replace(r'\s*GB', '', regex=True)

data1.head()

df=data1.copy()

df=df.drop('name',axis=1)



import re

# Function to extract the first float
def extract_first_float(text):
    match = re.search(r"[-+]?\d*\.\d+|\d+", text)  # Find the first match
    return float(match.group()) if match else None  # Return the float or None

# Apply the function to the column
df['diaplay_num'] = df['display'].apply(extract_first_float)





data1.head()

df.head()

df=df.drop('display',axis=1)

df.isna().sum()

# prompt: replace ram rom gb with '""

import pandas as pd
import numpy as np
import re
df=pd.read_csv('mobiles1.csv')
df.head()
df['reviews']=df['reviews'].str.replace("Reviews","")

df['battery_num'] = df['battery'].str.extract('(\d+)')
df['battery_num'] = pd.to_numeric(df['battery_num'], errors='coerce').fillna(0).astype(int)

df=df.drop(['battery'],axis=1)


df.head()
data1=df.copy()

data1[['RAM', 'ROM', 'Expandable_Memory']] = data1['memory'].str.extract(
    r'(\d+\s*GB\s*RAM)\s*\|\s*(\d+\s*GB\s*ROM)(?:\s*\|\s*Expandable\s*Upto\s*(\d+\s*GB))?'
)
data1.head()
data1['RAM'] = data1['RAM'].str.replace(r'GB', '', regex=True)
data1['ROM'] = data1['ROM'].str.replace(r'GB', '', regex=True)
data1['Expandable_Memory'] = data1['Expandable_Memory'].str.replace(r'\s*GB', '', regex=True)

# Replace "RAM", "ROM", and "Expandable_Memory" with empty strings where applicable
data1['RAM'] = data1['RAM'].str.replace(r'RAM', '', regex=True)
data1['ROM'] = data1['ROM'].str.replace(r'ROM', '', regex=True)
data1['Expandable_Memory'] = data1['Expandable_Memory'].str.replace(r'Expandable.*', '', regex=True)


data1.head()
df=data1.copy()
df=df.drop('name',axis=1)

# Function to extract the first float
def extract_first_float(text):
    match = re.search(r"[-+]?\d*\.\d+|\d+", text)  # Find the first match
    return float(match.group()) if match else None  # Return the float or None

# Apply the function to the column
df['diaplay_num'] = df['display'].apply(extract_first_float)


data1.head()
df.head()
df=df.drop('display',axis=1)
df.isna().sum()

data1['RAM'] = data1['RAM'].str.replace(r"RAM", '', regex=True)
data1['ROM'] = data1['ROM'].str.replace(r"ROM", '', regex=True)
data1['Expandable_Memory'] = data1['Expandable_Memory'].str.replace(r'Expandable.*', '', regex=True)

df['RAM'] = df['RAM'].str.replace(r"GB", '', regex=True)
df['ROM'] = df['ROM'].str.replace(r"GB", '', regex=True)
df['Expandable_Memory'] = df['Expandable_Memory'].str.replace(r'\s*GB', '', regex=True)

df['RAM'] = df['RAM'].astype(float)
df['ROM'] = df['ROM'].astype(float)

# prompt: replace ram and rom nan with min

# Fill NaN values in 'RAM' and 'ROM' columns with the minimum value of each column

df['RAM'] = df['RAM'].fillna(df['RAM'].min())
df['ROM'] = df['ROM'].fillna(df['ROM'].min())

# prompt: expandable memory with zero

# Fill NaN values in 'Expandable_Memory' with 0
df['Expandable_Memory'] = df['Expandable_Memory'].fillna(0)

# prompt: review and rating nan with 0

# Fill NaN values in 'reviews' with 0
df['reviews'] = df['reviews'].fillna(0)
df['rating'] = df['rating'].fillna(0)

df = df.dropna(subset=['processor'])
df=df.drop('memory',axis=1)

df.isna().sum()
df.head()

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score

df['Expandable_Memory']=df['Expandable_Memory'].astype(float)

df=df.drop('warranty',axis=1)

df.info()

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error

# Assuming df is your processed DataFrame and 'price' is your target variable
X = df.drop(columns=['price'])
y = df['price']

# Handle categorical variables by one-hot encoding
X_encoded = pd.get_dummies(X, drop_first=True)

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X_encoded, y, test_size=0.2, random_state=42)

# Initialize the RandomForestRegressor model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
rf_model.fit(X_train, y_train)

# Make predictions on the test set
y_pred_rf = rf_model.predict(X_test)

# Calculate R² (R-squared) and express it as percentage
r2_rf = r2_score(y_test, y_pred_rf)
r2_rf_percentage = r2_rf * 100
print(f"Random Forest R² Accuracy: {r2_rf_percentage:.2f}%")

# Calculate Mean Absolute Error (MAE) and relative accuracy
mae_rf = mean_absolute_error(y_test, y_pred_rf)
relative_accuracy_rf = (1 - mae_rf / y_test.mean()) * 100
print(f"Random Forest Relative Accuracy: {relative_accuracy_rf:.2f}%")

import pandas as pd

# Sample data for prediction (new data)
data = {
    'camera': ['12MP + 2MP | 8MP Front Camera', '12MP + 8MP + 2MP + 2MP | 8MP Front Camera', '13MP + 2MP | 5MP Front Camera','8MP  + 2MP+ 25MP |50 MP Front Camera'],
    'price': [9999, 11999, 7499, 18000],
    'processor': ['Qualcomm Snapdragon 439 Processor', 'Qualcomm Snapdragon 665 (2 GHz) Processor', 'MediaTek P22 Octa Core 2.0 GHz Processor','Exynos 1280'],
    'rating': [4.4, 4.5, 4.4,4.5],
    'reviews': [55078, 20062, 10091,2000],
    'battery_num': [5000, 5000, 4000, 6000],
    'RAM': [4.0, 4.0, 3.0, 6.0],
    'ROM': [64.0, 128.0, 32.0, 128],
    'Expandable_Memory': [512, 0, 256, 256],
    'diaplay_num': [15.80, 16.56, 15.49, 16.51]
}

# Convert to DataFrame
new_data = pd.DataFrame(data)

# Preprocess the new data (apply same transformations as the training data)
# Assuming 'X_encoded' from training data is already created
# Apply the same one-hot encoding and align columns

# One-hot encode the 'camera' and 'processor' columns
new_data_encoded = pd.get_dummies(new_data, drop_first=True)

# Align columns by adding missing columns (if any) and ensuring same order as the training data
# Ensure that the training data's encoded columns are available
new_data_encoded = new_data_encoded.reindex(columns=X_encoded.columns, fill_value=0)

# Make predictions with the trained model
predictions = rf_model.predict(new_data_encoded)

# Show the predictions
print(f"Predicted Prices: {predictions}")